#!/usr/bin/perl

##########################################################################
# Pandora FMS Plugin Server
# http://www.pandorafms.com
##########################################################################
# Copyright (c) 2008-2009 Sancho Lerena, slerena@gmail.com
#           (c) 2008-2009 Artica Soluciones Tecnologicas S.L
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
##########################################################################

# Includes list
use strict;
use warnings;

use Date::Manip;        # Needed to manipulate DateTime formats of input, output and compare
use Time::Local;        # DateTime basic manipulation
use threads;
use threads::shared;
use HTML::Entities;

# Pandora Modules
use PandoraFMS::Config;
use PandoraFMS::Tools;
use PandoraFMS::DB;

# Queue management
my @pending_task : shared;
my %pending_task_hash : shared;
my %current_task_hash : shared;
my $queue_lock : shared;


# FLUSH in each IO (only for debug, very slooow)
# ENABLED in DEBUGMODE
# DISABLE FOR PRODUCTION
$| = 0;

my %pa_config;

$SIG{'TERM'} = 'pandora_shutdown';
$SIG{'INT'} = 'pandora_shutdown';

# Inicio del bucle principal de programa
pandora_init(\%pa_config, "Pandora FMS Plugin Server");

# Check for pandora_exec
my $pandora_exec = "pandora_exec";
if (system("$pandora_exec > /dev/null 2>&1") != 256) {
	print " [E] $pandora_exec not found.\n\n";
	exit;
}

# Read config file for Global variables
pandora_loadconfig (\%pa_config, 4);

# Audit server starting
pandora_audit (\%pa_config, "Pandora FMS Plugin server starting", "SYSTEM", "System");

# Daemonize and put in background
if ( $pa_config{"daemon"} eq "1" ){
    if ($pa_config{"quiet"} eq "0"){
	    print " [*] Backgrounding Pandora FMS Plugin Server process.\n\n";
    }
	&pandora_daemonize ( \%pa_config);
}

# Launch now all plugin threads
# $ax is local thread id for this server
for (my $ax=0; $ax < $pa_config{'plugin_threads'}; $ax++){
	threads->new( \&pandora_plugin_consumer, \%pa_config, $ax);
}

# Launch now the producer thread
threads->new( \&pandora_plugin_producer, \%pa_config);

# Last thread is the main process (this process)
if ($pa_config{"quiet"} == 0){
    print " [*] All threads loaded and running \n\n";
}

# Start Pandora FMS loggin 
pandora_startlog (\%pa_config);

my $dbhost = $pa_config{'dbhost'};
my $dbname = $pa_config{'dbname'};
my $dbh = DBI->connect("DBI:mysql:$dbname:$dbhost:3306",
						$pa_config{'dbuser'},
						$pa_config{'dbpass'},
						{ RaiseError => 1, AutoCommit => 1 });

# Server keepalive thread running in main thread on a infinite loop
while (1) {
	pandora_serverkeepaliver (\%pa_config, 4, $dbh);
	threads->yield;
	sleep ($pa_config{"server_threshold"});
}

#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#---------------------  Main Perl Code below this line-----------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------

########################################################################################
# pandora_shutdown ()
# Close system
########################################################################################
sub pandora_shutdown {
    logger (\%pa_config,"Pandora FMS Server '".$pa_config{'servername'}.$pa_config{"servermode"}."' Shutdown by signal ",0);
    print " [*] Shutting down ".$pa_config{'servername'}.$pa_config{"servermode"} ."(received signal)...\n";
    pandora_event (\%pa_config, $pa_config{'servername'}.$pa_config{"servermode"}." going Down", 0,
                                   0, 4, 0, 0, "system", $dbh);
	pandora_updateserver (\%pa_config, $pa_config{'servername'}, 0, 4, $dbh);
    exit;
}

##########################################################################
# SUB pandora_plugin_consumer_subsystem
# Subsystem to process Plugin modules
# This module runs each X seconds (server threshold) checking for Plugin modules status
##########################################################################
sub pandora_plugin_consumer ($$) {
	my $pa_config = $_[0];
	my $thread_id = $_[1];

    if ($pa_config->{"quiet"} == 0){
	    print " [*] Starting up Plugin Consumer Thread # $thread_id \n";
    }
	
	my $data_id_agent_module;
	# Create Database handler
	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $counter =0;
	
	LOOP: while (1) {
		if ($counter > 10) {
            threads->yield;
			sleep (1);
			$counter = 0;
		}
		
		# Take the first element on the shared queue
		# Insert this element on the current task hash
		{
			lock $queue_lock;
			if (scalar(@pending_task) == 0){
				$counter++;
				next LOOP;
			}

			$data_id_agent_module = shift(@pending_task);
			delete($pending_task_hash{$data_id_agent_module});
			$current_task_hash{$data_id_agent_module}=1;
		}
			
		# Executing network task with unmanaged error trapping
		eval {
			# Call network execution process
			# exec_network_module ( $pa_config, $data_id_agent_module, $dbh);
        	        exec_plugin_module ($pa_config, $data_id_agent_module, $dbh);
		};
		if ($@){
			logger ($pa_config, "[ERROR] Plugin Task for module $data_id_agent_module causes a system exception", 0);
			logger ($pa_config, "ERROR Code: $@", 1);
		}

		# Remove from queue. If catch an error, probably data is
		# not been processed, but has been freed from task queue
		{
			lock $queue_lock;
			delete($current_task_hash{$data_id_agent_module});
		}
		$counter = 0;
        threads->yield;
	}
}

sub pandora_plugin_producer ($) {
	my $pa_config = $_[0];
	print " [*] Starting up Plugin Producer Thread ...\n";

	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $server_id = $pa_config->{'server_id'};

	# Initialize variables for posterior usage
	my $query1;
	my @sql_data1;
	my $data_id_agente_modulo;
	my $data_flag;
	my $exec_sql1;
	
	while (1) {
		if ($pa_config->{"pandora_master"} != 1) {
			# Query for normal server, not MASTER server
                        $query1 = "SELECT
                                tagente_modulo.id_agente_modulo,
                                tagente_modulo.flag
                                UNIX_TIMESTAMP() - tagente_estado.current_interval - tagente_estado.last_execution_try  AS time_left  
                        FROM
                                tagente, tagente_modulo, tagente_estado
                        WHERE
                                id_plugin_server = $server_id
                        AND
                                tagente_modulo.id_agente = tagente.id_agente
                        AND
                                tagente.disabled = 0
            		AND
                		tagente_modulo.id_plugin != 0
                        AND
                                tagente_modulo.disabled = 0
                        AND
                                tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
                        AND (
                                        tagente_modulo.flag = 1
                                OR
                                        (tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP()
                        )
                        ORDER BY
                                        tagente_modulo.flag DESC, time_left DESC, last_execution_try ASC ";
                } else {
                        # Query for MASTER SERVER !
                        $query1 = "SELECT
                                        DISTINCT(tagente_modulo.id_agente_modulo), tagente_modulo.flag, UNIX_TIMESTAMP() - tagente_estado.current_interval - tagente_estado.last_execution_try  AS time_left  
                                FROM
                                        tagente, tagente_modulo, tagente_estado
                                WHERE
                                (       (tagente.id_plugin_server = $server_id) OR
                                        (tagente.id_plugin_server = ANY(SELECT id_server FROM tserver WHERE status = 0 AND id_server != $server_id AND plugin_server = 1))
                                ) 
                                AND
                        		tagente_modulo.id_agente = tagente.id_agente
               			AND
                                        tagente.disabled = 0
                		AND
                    			tagente_modulo.disabled = 0
                                AND
                                        tagente_modulo.id_plugin != 0
                                AND
                                        tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
                                AND
                                        (tagente_modulo.flag = 1 OR (tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP() )
                                ORDER BY 
	                                	tagente_modulo.flag DESC, time_left DESC, last_execution_try ASC";
		}
		$exec_sql1 = $dbh->prepare($query1);
		$exec_sql1 ->execute;
		while (@sql_data1 = $exec_sql1->fetchrow_array()) {	
			$data_id_agente_modulo = $sql_data1[0];
			$data_flag = $sql_data1[1];

			# Skip modules already queued
			if ((!defined($pending_task_hash{$data_id_agente_modulo})) &&
				(!defined($current_task_hash{$data_id_agente_modulo}))) {
				if ($data_flag == 1){
					$dbh->do("UPDATE tagente_modulo SET flag = 0 WHERE id_agente_modulo = $data_id_agente_modulo")
				}
				# Locking scope, do not remove redundant { }
				{
					lock $queue_lock;
					push (@pending_task, $data_id_agente_modulo);
					$pending_task_hash {$data_id_agente_modulo}=1;
				}
			}
		}
		$exec_sql1->finish();
        threads->yield;
		sleep($pa_config->{"server_threshold"});
	} # Main loop
}


##########################################################################
# SUB exec_plugin_module (paconfig, id_agente_modulo, dbh )
# Execute plugin module task 
##########################################################################
sub exec_plugin_module {
	my $pa_config       = $_[0];
	my $id_am           = $_[1];
	my $dbh             = $_[2];

	# Set global variables for this sub
	my $timeout = $pa_config->{'plugin_timeout'};
	my $agent_module; # hash container for tagente_modulo record
	my $plugin; # hash container for tplugin

	# Get a full hash for agent_plugin record reference ($agent_module)
	my $query_sql = "SELECT * FROM tagente_modulo WHERE id_agente_modulo = $id_am";
	my $exec_sql = $dbh->prepare($query_sql);
	$exec_sql ->execute;
	$agent_module = $exec_sql->fetchrow_hashref;

	# Get a full hash for plugin record reference ($plugin)
	$query_sql = "SELECT * FROM tplugin WHERE id = ".$agent_module->{'id_plugin'};
	$exec_sql = $dbh->prepare($query_sql);
	$exec_sql->execute();
	$plugin = $exec_sql->fetchrow_hashref;

	# Calculate min timeout for this call
	if ($plugin->{'max_timeout'} < $timeout){
		$timeout = $plugin->{'max_timeout'};
	}

	# Initialize another global sub variables.
	my $agent_name = dame_agente_nombre ($pa_config, $agent_module->{'id_agente'}, $dbh);
	my $module_data = 0;    # 0 data for default
	my $module_interval = 0;

	# Build execution command to plugin
	my $exec_output = "";
	my $plugin_command = $plugin->{"execute"};
	if ($plugin->{'net_dst_opt'} ne ""){
		$plugin_command = $plugin_command . " ". $plugin->{'net_dst_opt'} ." ". $agent_module->{'ip_target'};
	} 
	if ($plugin->{'net_port_opt'} ne "") {
		$plugin_command = $plugin_command . " ". $plugin->{'net_port_opt'} ." ". $agent_module->{'tcp_port'};
	}
	if ($plugin->{'user_opt'} ne "") {
		$plugin_command = $plugin_command . " ". $plugin->{'user_opt'} ." ". $agent_module->{'plugin_user'};
	}
	if ($plugin->{'pass_opt'} ne "") {
		$plugin_command = $plugin_command . " ". $plugin->{'pass_opt'} ." ". $agent_module->{'plugin_pass'};
	}

	# Proccess field / optional / dynamic field
	if ($agent_module->{'plugin_parameter'} ne "") {
		$plugin_command = $plugin_command . " ". $agent_module->{'plugin_parameter'};
	}

	$plugin_command = decode_entities($plugin_command);

	logger ($pa_config, "Executing AM # $id_am plugin command '$plugin_command'", 9);
	# Final command line execution is stored at "plugin_command"

	$module_data = `$pandora_exec $timeout $plugin_command`;
	if ($module_data eq "") {
		update_on_error ($pa_config, $id_am, $dbh);
		undef $plugin;
		undef $agent_module;
		return;
	} 

	# Get current timestamp
	my $timestamp = &UnixDate("today","%Y-%m-%d %H:%M:%S");
	my $utimestamp = &UnixDate("today","%s");

	my %part;
	$part{'name'}[0] = $agent_module->{'nombre'};
	$part{'description'}[0] = "";
	$part{'data'}[0] = $module_data;
        my $tipo_modulo = dame_nombretipomodulo_idagentemodulo ($pa_config, $agent_module->{'id_tipo_modulo'}, $dbh);

        # 1 - generic_data
        # 2 - generic_proc
        # 3 - generic_data_string
        # 4 - generic_data_inc
        # 19, 20 - image

	if (1 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_data ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
	elsif (4 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_data_inc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
	elsif (3 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_data_string ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
        # Generic_proc
	elsif (2 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_proc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
        elsif ( (19 == $agent_module->{'id_tipo_modulo'}) || (20 == $agent_module->{'id_tipo_modulo'}) ) {
            module_generic_image ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
        }
	else { # Unknown module!, this IS a problem
		logger ($pa_config, "Plugin Server Problem with unknown module type '$tipo_modulo'", 0);
	}
	# Update agent last contact
	# Insert Pandora version as agent version
	pandora_lastagentcontact ($pa_config, $timestamp, $agent_name,  $pa_config->{'servername'}.$pa_config->{"servermode"}, $pa_config->{'version'}, -1, $dbh);
	 
	$exec_sql->finish(); #close tagent_plugin hash reference
	undef $plugin;
	undef $agent_module;
	undef %part;
}
