#!/usr/bin/perl
##########################################################################
# Pandora FMS WMI Server
# http://www.pandorafms.com
##########################################################################
# Copyright (c) 2008-2009 Artica Soluciones Tecnologicas S.L
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
##########################################################################

# Includes list
use strict;
use warnings;

use Date::Manip;        # Needed to manipulate DateTime formats of input, output and compare
use Time::Local;        # DateTime basic manipulation
use threads;
use threads::shared;
use HTML::Entities;

# Pandora Modules
use PandoraFMS::Config;
use PandoraFMS::Tools;
use PandoraFMS::DB;
# use Win32::OLE qw(in);

# Queue management
my @pending_task : shared;
my %pending_task_hash : shared;
my %current_task_hash : shared;
my $queue_lock : shared;

# FLUSH in each IO (only for debug, very slooow)
# ENABLED in DEBUGMODE
# DISABLE FOR PRODUCTION
$| = 0;

my %pa_config;

$SIG{'TERM'} = 'pandora_shutdown';
$SIG{'INT'} = 'pandora_shutdown';

# Inicio del bucle principal de programa
pandora_init(\%pa_config, "Pandora FMS WMI Server");

# Check for wmic
my $wmi_client = "wmic";
if (system("$wmi_client > /dev/null 2>&1") != 256) {
	print " [E] $wmi_client not found. Pandora FMS WMI Server needs a DCOM/WMI client.\n\n";
	exit;
}

# Read config file for Global variables
pandora_loadconfig (\%pa_config, 6);

# Audit server starting
pandora_audit (\%pa_config, "Pandora FMS WMI server starting", "SYSTEM", "System");

# Daemonize and put in background
if ( $pa_config{"daemon"} eq "1" ){
    if ($pa_config{"quiet"} eq "0"){
	    print " [*] Backgrounding Pandora FMS WMI Server process.\n\n";
    }
	&pandora_daemonize ( \%pa_config);
}

# Launch now all WMI server threads
for (my $i=0; $i < $pa_config{'wmi_threads'}; $i++){
	threads->new( \&pandora_wmi_consumer, \%pa_config, $i);
}

# Launch now the producer thread
threads->new( \&pandora_wmi_producer, \%pa_config);

# Last thread is the main process (this process)
if ($pa_config{"quiet"} == 0){
    print " [*] All threads loaded and running \n\n";
}

# Start Pandora FMS loggin 
pandora_startlog (\%pa_config);

my $dbhost = $pa_config{'dbhost'};
my $dbname = $pa_config{'dbname'};
my $dbh = DBI->connect("DBI:mysql:$dbname:$dbhost:3306",
						$pa_config{'dbuser'},
						$pa_config{'dbpass'},
						{ RaiseError => 1, AutoCommit => 1 });

# Server keepalive thread running in main thread on a infinite loop
while (1) {
	pandora_serverkeepaliver (\%pa_config, 6, $dbh);
	threads->yield;
	sleep ($pa_config{"server_threshold"});
}


#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#---------------------  Main Perl Code below this line-----------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------

########################################################################################
# pandora_shutdown ()
# Close system
########################################################################################
sub pandora_shutdown {
    logger (\%pa_config,"Pandora FMS Server '".$pa_config{'servername'}.$pa_config{"servermode"}."' Shutdown by signal ",0);
    print " [*] Shutting down ".$pa_config{'servername'}.$pa_config{"servermode"} ."(received signal)...\n";
    pandora_event (\%pa_config, $pa_config{'servername'}.$pa_config{"servermode"}." going Down", 0,
                                   0, 4, 0, 0, "system", $dbh);
	pandora_updateserver (\%pa_config, $pa_config{'servername'}, 0, 6, $dbh);
    exit;
}

##########################################################################
# SUB pandora_wmi_consumer subsystem
# Subsystem to process WMI modules
# This module runs each X seconds (server threshold) checking for WMI  modules status
##########################################################################
sub pandora_wmi_consumer ($$) {
	my $pa_config = $_[0];
	my $thread_id = $_[1];

    if ($pa_config->{"quiet"} == 0){
	    print " [*] Starting up WMI Consumer Thread # $thread_id \n";
    }
	
	my $data_id_agent_module;
	# Create Database handler
	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $counter =0;
	
	LOOP: while (1) {
		if ($counter > 10) {
            threads->yield;
			sleep (1);
			$counter = 0;
		}
		
		# Take the first element on the shared queue
		# Insert this element on the current task hash
		{
			lock $queue_lock;
			if (scalar(@pending_task) == 0){
				$counter++;
				next LOOP;
			}

			$data_id_agent_module = shift(@pending_task);
			delete($pending_task_hash{$data_id_agent_module});
			$current_task_hash{$data_id_agent_module}=1;
		}
		eval {
			exec_wmi_module ($pa_config, $data_id_agent_module, $dbh);
		};
		if ($@){
			logger ($pa_config, "[ERROR] WMI Task for module $data_id_agent_module causes a system exception", 0);
			logger ($pa_config, "ERROR Code: $@", 1);
		}

		# Remove from queue. If catch an error, probably data is
		# not been processed, but has been freed from task queue
		{
			lock $queue_lock;
			delete ($current_task_hash {$data_id_agent_module} );
		}
		$counter = 0;
        threads->yield;
	}
}

sub pandora_wmi_producer ($) {
	my $pa_config = $_[0];
	print " [*] Starting up WMI Producer Thread ...\n";

	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $server_id = $pa_config->{'server_id'};

	# Initialize variables for posterior usage
	my $query1;
	my @sql_data1;
	my $data_id_agente_modulo;
	my $data_flag;
	my $exec_sql1;
	
	while (1) {
		if ($pa_config->{"pandora_master"} != 1) {
			# Query for normal server, not MASTER server
			$query1 = "SELECT
				tagente_modulo.id_agente_modulo,
				tagente_modulo.flag
				UNIX_TIMESTAMP() - tagente_estado.current_interval - tagente_estado.last_execution_try  AS time_left  
			FROM
				tagente, tagente_modulo, tagente_estado
			WHERE
				id_wmi_server = $server_id
			AND 
				tagente_modulo.id_agente = tagente.id_agente
			AND
				tagente.disabled = 0
            AND
                tagente_modulo.id_modulo = 6
			AND
				tagente_modulo.disabled = 0
			AND
				tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
			AND (
					(tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP() 
				OR 
					tagente_modulo.flag = 1
			)				
			ORDER BY
					tagente_modulo.flag DESC, time_left DESC, last_execution_try ASC  ";
		} else {
			# Query for MASTER SERVER !
			$query1 = "SELECT
					DISTINCT(tagente_modulo.id_agente_modulo), tagente_modulo.flag, UNIX_TIMESTAMP() - tagente_estado.current_interval - tagente_estado.last_execution_try  AS time_left  
				FROM
					tagente, tagente_modulo, tagente_estado, tserver
				WHERE
				( 	(tagente.id_wmi_server = $server_id AND tagente_modulo.id_agente = tagente.id_agente) OR
					(tagente.id_wmi_server != $server_id AND tagente_modulo.id_agente = tagente.id_agente AND tagente.id_wmi_server = tserver.id_server AND tserver.status = 0)
				) AND
					tagente.disabled = 0
                AND 
                    tagente_modulo.disabled = 0
				AND
					tagente_modulo.id_modulo = 6
				AND
					tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
				AND
					((tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP() OR tagente_modulo.flag = 1 )
				ORDER BY 
					tagente_modulo.flag DESC, time_left DESC, last_execution_try ASC";
		}
		$exec_sql1 = $dbh->prepare($query1);
		$exec_sql1 ->execute;
		while (@sql_data1 = $exec_sql1->fetchrow_array()) {	
			$data_id_agente_modulo = $sql_data1[0];
			$data_flag = $sql_data1[1];

			# Skip modules already queued
			if ((!defined($pending_task_hash{$data_id_agente_modulo})) &&
				(!defined($current_task_hash{$data_id_agente_modulo}))) {
				if ($data_flag == 1){
					$dbh->do("UPDATE tagente_modulo SET flag = 0 WHERE id_agente_modulo = $data_id_agente_modulo")
				}
				# Locking scope, do not remove redundant { }
				{
					lock $queue_lock;
					push (@pending_task, $data_id_agente_modulo);
					$pending_task_hash {$data_id_agente_modulo}=1;
				}
			}
		}
		$exec_sql1->finish();
        threads->yield;
		sleep($pa_config->{"server_threshold"});
	} # Main loop
}

##########################################################################
# SUB exec_wmi_module (paconfig, id_agente_modulo, dbh )
# Execute WMI module task 
##########################################################################
sub exec_wmi_module {
	my $pa_config       = $_[0];
	my $id_am           = $_[1];
	my $dbh             = $_[2];

	# Set global variables for this sub
	my $timeout = $pa_config->{'wmi_timeout'};
	my $agent_module; # hash container for tagente_modulo record

	# Get a full hash for agent_plugin record reference ($agent_module)
	my $query_sql = "SELECT * FROM tagente_modulo WHERE id_agente_modulo = $id_am";
	my $exec_sql = $dbh->prepare($query_sql);
	$exec_sql ->execute;
	$agent_module = $exec_sql->fetchrow_hashref;

	# Calculate min timeout for this call
	if ($agent_module->{'max_timeout'} < $timeout){
		$timeout = $agent_module->{'max_timeout'};
	}

	# Initialize another global sub variables.
	my $agent_name = dame_agente_nombre ($pa_config, $agent_module->{'id_agente'}, $dbh);
	my $module_interval =  $agent_module->{'module_interval'};

	# Build execution command to plugin

	my $wmi_query = decode_entities($agent_module->{'snmp_oid'});
	$wmi_query =~ s/\"/\'/g;

	my $wmi_command = "$wmi_client -U \"". $agent_module->{'plugin_user'} ."\"%\"". $agent_module->{'plugin_pass'} . "\"";
    
	# Custom namespace
	if ($agent_module->{'tcp_send'} ne '') {
		$agent_module->{'tcp_send'} =~ s/\"/\'/g;
		$wmi_command .= " --namespace=\"" . $agent_module->{'tcp_send'} . "\"";
	}

	$wmi_command .= " //". $agent_module->{'ip_target'};
	$wmi_command .= " \"". $wmi_query . "\"";
	logger ($pa_config, "Executing AM # $id_am WMI command '$wmi_command'", 9);
    
	my $module_data = `$wmi_command`;
	if (! defined($module_data)) {
		update_on_error ($pa_config, $id_am, $dbh);
		undef $agent_module;
		return;
	}

	my @data = split("\n", $module_data);
	if ($#data < 2) {
		update_on_error ($pa_config, $id_am, $dbh);
		undef $agent_module;
		return;
	}

	my @data2 = split(/\|/, $data[2]); # get third line (containing data)

	# Take a specific field number from returned data. It uses tcp_port
	# field from tagente_module table.

	$module_data = $data2[$agent_module -> {'tcp_port'}];
		
	# Look for errors
	if ($module_data =~ /ERROR/) {
		update_on_error ($pa_config, $id_am, $dbh);
		undef $agent_module;
		return 0;
	} 

	# Special word to know is something is OK or not, 
	# for example "Running". Defined by user in console. It uses snmp_community 
	# field from tagente_modulo.

	if ($agent_module -> {'snmp_community'} ne ""){
		my $temp_filter1 = $agent_module -> {'snmp_community'};
		if ($module_data =~ /$temp_filter1/){
			$module_data = 1;
		} else {
			$module_data = 0;
		}
	}

	# Get current timestamp
	my $timestamp = &UnixDate("today","%Y-%m-%d %H:%M:%S");
	my $utimestamp = &UnixDate("today","%s");

	# If module execution get a valid value
	my %part;
	$part{'name'}[0] = $agent_module->{'nombre'};
	$part{'description'}[0] = "";
	$part{'data'}[0] = $module_data;
        my $tipo_modulo = dame_nombretipomodulo_idagentemodulo ($pa_config, $agent_module->{'id_tipo_modulo'}, $dbh);

        # 1 - generic_data
        # 2 - generic_proc
        # 3 - generic_data_string
        # 4 - generic_data_inc

	if (1 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_data ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
	elsif (4 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_data_inc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
	elsif (3 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_data_string ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
        # Generic_proc
	elsif (2 == $agent_module->{'id_tipo_modulo'}) {
		module_generic_proc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
	}
	else { # Unknown module!, this IS a problem
		logger ($pa_config, "WMI Server Problem with unknown module type '$tipo_modulo'", 0);
		update_on_error ($pa_config, $id_am, $dbh);
		undef $agent_module;
		undef %part;
		return 0;
	}
	# Update agent last contact
	# Insert Pandora version as agent version
	pandora_lastagentcontact ($pa_config, $timestamp, $agent_name,  $pa_config->{'servername'}.$pa_config->{"servermode"}, $pa_config->{'version'}, -1, $dbh);

	$exec_sql->finish(); #close tagent_plugin hash reference
	undef %part;
	undef $agent_module;
}
