#!/usr/bin/perl
##########################################################################
# Pandora FMS WMI Server
# http://www.pandorafms.com
##########################################################################
# Copyright (c) 2008 Sancho Lerena, slerena@gmail.com
#           (c) 2008 Artica Soluciones Tecnologicas S.L
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
##########################################################################

# Includes list
use strict;
use warnings;

use Date::Manip;        # Needed to manipulate DateTime formats of input, output and compare
use Time::Local;        # DateTime basic manipulation
use threads;
use threads::shared;
use HTML::Entities;

# Pandora Modules
use PandoraFMS::Config;
use PandoraFMS::Tools;
use PandoraFMS::DB;
# use Win32::OLE qw(in);

# Queue management
my @pending_task : shared;
my %pending_task_hash : shared;
my %current_task_hash : shared;
my $queue_lock : shared;

# FLUSH in each IO (only for debug, very slooow)
# ENABLED in DEBUGMODE
# DISABLE FOR PRODUCTION
$| = 0;

my %pa_config;

$SIG{'TERM'} = 'pandora_shutdown';
$SIG{'INT'} = 'pandora_shutdown';

# Inicio del bucle principal de programa
pandora_init(\%pa_config, "Pandora FMS WMI Server");

# Check for wmic
my $wmi_client = "wmic";
if (system("$wmi_client > /dev/null 2>&1") != 256) {
	print " [E] $wmi_client not found. Pandora FMS WMI Server needs a DCOM/WMI client.\n\n";
	exit;
}

# Read config file for Global variables
pandora_loadconfig (\%pa_config, 6);

# Audit server starting
pandora_audit (\%pa_config, "Pandora FMS WMI server starting", "SYSTEM", "System");

# Daemonize and put in background
if ( $pa_config{"daemon"} eq "1" ){
    if ($pa_config{"quiet"} eq "0"){
	    print " [*] Backgrounding Pandora FMS WMI Server process.\n\n";
    }
	&pandora_daemonize ( \%pa_config);
}

# Launch now all WMI server threads
for (my $i=0; $i < $pa_config{'wmi_threads'}; $i++){
	threads->new( \&pandora_wmi_consumer, \%pa_config, $i);
}

# Launch now the producer thread
threads->new( \&pandora_wmi_producer, \%pa_config);

# Last thread is the main process (this process)
if ($pa_config{"quiet"} == 0){
    print " [*] All threads loaded and running \n\n";
}

# Start Pandora FMS loggin 
pandora_startlog (\%pa_config);

my $dbhost = $pa_config{'dbhost'};
my $dbname = $pa_config{'dbname'};
my $dbh = DBI->connect("DBI:mysql:$dbname:$dbhost:3306",
						$pa_config{'dbuser'},
						$pa_config{'dbpass'},
						{ RaiseError => 1, AutoCommit => 1 });

# Server keepalive thread running in main thread on a infinite loop
while (1) {
	pandora_serverkeepaliver (\%pa_config, 6, $dbh);
	threads->yield;
	sleep ($pa_config{"server_threshold"});
}



# New samples

# Process executing (return PID)
# SELECT ProcessId FROM Win32_Process WHERE Caption = "spoolsv.exe"

# Service State of a service (Running or Stopped)
# SELECT State FROM Win32_Service WHERE Name = "Eventlog"

# CPU de CPU0
# SELECT LoadPercentage from Win32_Processor WHERE DeviceID = "CPU0"

# Available memory (bytes)
# SELECT AvailableBytes from Win32_PerfRawData_PerfOS_Memory

# Available cache memory (bytes)
# SELECT CacheBytes from Win32_PerfRawData_PerfOS_Memory

# AvgDiskBytesPerTransfer 
# DiskReadsPersec
# DiskTransfersPersec
# FreeMegabytes
# SELECT * from Win32_PerfRawData_PerfDisk_LogicalDisk WHERE Name = "F:"


# FragmentedDatagramsPersec
# FragmentationFailures
# DatagramsReceivedPersec
# DatagramsSentPersec
# SELECT * from Win32_PerfFormattedData_Tcpip_IP

#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#---------------------  Main Perl Code below this line-----------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------

########################################################################################
# pandora_shutdown ()
# Close system
########################################################################################
sub pandora_shutdown {
    logger (\%pa_config,"Pandora FMS Server '".$pa_config{'servername'}.$pa_config{"servermode"}."' Shutdown by signal ",0);
    print " [*] Shutting down ".$pa_config{'servername'}.$pa_config{"servermode"} ."(received signal)...\n";
    pandora_event (\%pa_config, $pa_config{'servername'}.$pa_config{"servermode"}." going Down", 0,
                                   0, 4, 0, 0, "system", $dbh);
	pandora_updateserver (\%pa_config, $pa_config{'servername'}, 0, 6, $dbh);
    exit;
}

##########################################################################
# SUB pandora_wmi_consumer subsystem
# Subsystem to process WMI modules
# This module runs each X seconds (server threshold) checking for WMI  modules status
##########################################################################
sub pandora_wmi_consumer ($$) {
	my $pa_config = $_[0];
	my $thread_id = $_[1];

    if ($pa_config->{"quiet"} == 0){
	    print " [*] Starting up WMI Consumer Thread # $thread_id \n";
    }
	
	my $data_id_agent_module;
	# Create Database handler
	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $counter =0;
	
	LOOP: while (1) {
		if ($counter > 10) {
            threads->yield;
			sleep (1);
			$counter = 0;
		}
		
		# Take the first element on the shared queue
		# Insert this element on the current task hash
		{
			lock $queue_lock;
			if (scalar(@pending_task) == 0){
				$counter++;
				next LOOP;
			}

			$data_id_agent_module = shift(@pending_task);
			delete($pending_task_hash{$data_id_agent_module});
			$current_task_hash{$data_id_agent_module}=1;
		}
		eval {
			exec_wmi_module ($pa_config, $data_id_agent_module, $dbh);
		};
		if ($@){
			logger ($pa_config, "[ERROR] WMI Task for module $data_id_agent_module causes a system exception", 0);
			logger ($pa_config, "ERROR Code: $@", 1);
		}

		# Remove from queue. If catch an error, probably data is
		# not been processed, but has been freed from task queue
		{
			lock $queue_lock;
			delete ($current_task_hash {$data_id_agent_module} );
		}
		$counter = 0;
        threads->yield;
	}
}

sub pandora_wmi_producer ($) {
	my $pa_config = $_[0];
	print " [*] Starting up WMI Producer Thread ...\n";

	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $server_id = $pa_config->{'server_id'};

	# Initialize variables for posterior usage
	my $query1;
	my @sql_data1;
	my $data_id_agente_modulo;
	my $data_flag;
	my $exec_sql1;
	
	while (1) {
		if ($pa_config->{"pandora_master"} != 1) {
			# Query for normal server, not MASTER server
			$query1 = "SELECT
				tagente_modulo.id_agente_modulo,
				tagente_modulo.flag
			FROM
				tagente, tagente_modulo, tagente_estado
			WHERE
				id_wmi_server = $server_id
			AND 
				tagente_modulo.id_agente = tagente.id_agente
			AND
				tagente.disabled = 0
            AND
                tagente_modulo.id_modulo = 6
			AND
				tagente_modulo.disabled = 0
			AND
				tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
			AND (
					(tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP() 
				OR 
					tagente_modulo.flag = 1
			)				
			ORDER BY
					last_execution_try ASC  ";
		} else {
			# Query for MASTER SERVER !
			$query1 = "SELECT
					DISTINCT(tagente_modulo.id_agente_modulo), tagente_modulo.flag
				FROM
					tagente, tagente_modulo, tagente_estado, tserver
				WHERE
				( 	(tagente.id_wmi_server = $server_id AND tagente_modulo.id_agente = tagente.id_agente) OR
					(tagente.id_wmi_server != $server_id AND tagente_modulo.id_agente = tagente.id_agente AND tagente.id_wmi_server = tserver.id_server AND tserver.status = 0)
				) AND
					tagente.disabled = 0
                AND 
                    tagente_modulo.disabled = 0
				AND
					tagente_modulo.id_modulo = 6
				AND
					tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
				AND
					((tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP() OR tagente_modulo.flag = 1 )
				ORDER BY last_execution_try ASC";
		}
		$exec_sql1 = $dbh->prepare($query1);
		$exec_sql1 ->execute;
		while (@sql_data1 = $exec_sql1->fetchrow_array()) {	
			$data_id_agente_modulo = $sql_data1[0];
			$data_flag = $sql_data1[1];

			# Skip modules already queued
			if ((!defined($pending_task_hash{$data_id_agente_modulo})) &&
				(!defined($current_task_hash{$data_id_agente_modulo}))) {
				if ($data_flag == 1){
					$dbh->do("UPDATE tagente_modulo SET flag = 0 WHERE id_agente_modulo = $data_id_agente_modulo")
				}
				# Locking scope, do not remove redundant { }
				{
					lock $queue_lock;
					push (@pending_task, $data_id_agente_modulo);
					$pending_task_hash {$data_id_agente_modulo}=1;
				}
			}
		}
		$exec_sql1->finish();
        threads->yield;
		sleep($pa_config->{"server_threshold"});
	} # Main loop
}


##########################################################################
# SUB exec_wmi_module (paconfig, id_agente_modulo, dbh )
# Execute WMI module task 
##########################################################################
sub exec_wmi_module {
    my $pa_config       = $_[0];
    my $id_am           = $_[1];
    my $dbh             = $_[2];

    # Set global variables for this sub
    my $timeout = $pa_config->{'wmi_timeout'};
	my $agent_module; # hash container for tagente_modulo record

    # Get a full hash for agent_plugin record reference ($agent_module)
	my $query_sql = "SELECT * FROM tagente_modulo WHERE id_agente_modulo = $id_am";
	my $exec_sql = $dbh->prepare($query_sql);
	$exec_sql ->execute;
	$agent_module = $exec_sql->fetchrow_hashref;

    # Calculate min timeout for this call
    if ($agent_module->{'max_timeout'} < $timeout){
        $timeout = $agent_module->{'max_timeout'};
    }

    # Initialize another global sub variables.
	my $agent_name = dame_agente_nombre ($pa_config, $agent_module->{'id_agente'}, $dbh);
	my $module_result = 1;  # Fail by default
	my $module_data = 0;    # 0 data for default
    my $module_interval = 0;

    # Build execution command to plugin
	# Sample exec:  wmic -U Administrador%none //192.168.50.123 "SELECT State FROM Win32_Service WHERE Name = \"Eventlog\""

	# This returns several lines that needs to be processed
	# OM Win32_Service WHERE Name = \"Eventlog\""
	# CLASS: Win32_Service
	# Name|State
	# Eventlog|Running

	my $wmi_query = decode_entities($agent_module->{'snmp_oid'});
	$wmi_query =~ s/\"/\'/g;

    my $wmi_command = "$wmi_client -U \"". $agent_module->{'plugin_user'} ."\"%\"". $agent_module->{'plugin_pass'} . "\"";
    $wmi_command .= " //". $agent_module->{'ip_target'};
    $wmi_command .= " \"". $wmi_query . "\"";
    logger ($pa_config, "Executing AM # $id_am WMI command '$wmi_command'", 9);
    
    eval {
        alarm ($timeout);
        $module_data = `$wmi_command`;
		my @data = split("\n", $module_data); 
		my @data2 = split(/\|/, $data[2]); # get third line (containing data)

		# Take a specific field number from returned data. It uses tcp_port
		# field from tagente_module table.

		$module_data = $data2[$agent_module -> {'tcp_port'}];
        alarm(0); # Cancel the pending alarm if plugin call returns alive
		
		# Look for errors
		if ($module_data =~ /ERROR/) {
			$module_result = 1;
		} else {
        	$module_result = 0; # If comes here, this is a successfull exec
		}

		# Special word to know is something is OK or not, 
		# for example "Running". Defined by user in console. It uses snmp_community 
		# field from tagente_modulo.

		if ($agent_module -> {'snmp_community'} ne ""){
			my $temp_filter1 = $agent_module -> {'snmp_community'};
			if ($module_data =~ /$temp_filter1/){
				$module_data = 1;
			} else {
				$module_data = 0;
			}
		}
    };

    # Timeout 
    if ($@ =~ /PANDORA WMI SERVER TIMED OUT/) {
        logger ($pa_config, "[ERROR] WMI Task for module ".$agent_module->{'id_agente_modulo'}." causes a system timeout in exec", 1);
        logger ($pa_config, "Executing WMI command '$wmi_command'", 9);

    # General error, not timed-out
    } elsif ($module_result == 1) { 
        logger ($pa_config, "[ERROR] Plugin Task for module ".$agent_module->{'id_agente_modulo'}." causes an unknown system error", 1);
        logger ($pa_config, "[ERROR] $@", 1);
    }

    sub timed_out {
        die "PANDORA WMI SERVER TIMED OUT";
    }

	# Get current timestamp
	my $timestamp = &UnixDate("today","%Y-%m-%d %H:%M:%S");
	my $utimestamp = &UnixDate("today","%s");

    # If module execution get a valid value
	if ($module_result == 0) {
		my %part;
		$part{'name'}[0] = $agent_module->{'nombre'};
		$part{'description'}[0] = "";
		$part{'data'}[0] = $module_data;
        my $tipo_modulo = dame_nombretipomodulo_idagentemodulo ($pa_config, $agent_module->{'id_tipo_modulo'}, $dbh);

        # 1 - generic_data
        # 2 - generic_proc
        # 3 - generic_data_string
        # 4 - generic_data_inc
        # 19, 20 - image

		if (1 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_data ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
		elsif (4 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_data_inc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
		elsif (3 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_data_string ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
        # Generic_proc
		elsif (2 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_proc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
        elsif ( (19 == $agent_module->{'id_tipo_modulo'}) || (20 == $agent_module->{'id_tipo_modulo'}) ) {
            module_generic_image ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
        }
		else { # Unknown module!, this IS a problem
			logger ($pa_config, "WMI Server Problem with unknown module type '$tipo_modulo'", 0);
            $module_result = 1;
		}
		# Update agent last contact
		# Insert Pandora version as agent version
		pandora_lastagentcontact ($pa_config, $timestamp, $agent_name,  $pa_config->{'servername'}.$pa_config->{"servermode"}, $pa_config->{'version'}, -1, $dbh);
	} 

    # If something went wrong in module processing...
    if ($module_result != 0){ 

        # If module execution get a INVALID value
		if ($agent_module->{'intervalo'} == 0){
            $module_interval = dame_intervalo ($pa_config, $agent_module->{'id_agente'}, $dbh);
        }

		# Modules who cannot connect or something go bad, update last_execution_try field
		logger ($pa_config, "Cannot obtain exec WMI  Module ".$agent_module->{'nombre'}." from agent $agent_name", 2);
		my $query_act = "UPDATE tagente_estado SET current_interval = $module_interval, last_execution_try = $utimestamp WHERE id_agente_modulo = ".$agent_module->{'id_agente_modulo'};
        $dbh->do($query_act);
	}

	$exec_sql->finish(); #close tagent_plugin hash reference
}
